<!DOCTYPE html>

<head>
  <title>Embedded Programming</title>

  <link rel="stylesheet" href="style.css">

  <script src="jquery-3.5.1.min.js"></script>

</head>

<body>

  <div id="nav-placeholder">

  </div>

  <script>
    $(function () {
      $("#nav-placeholder").load("nav.html");
    });
  </script>

  <div style="margin-left:25%;padding:1px 16px;height:1000px;">


    <h1>Embedded Programming</h1>

    <h2>Using AVRDude</h2>

    <p>Configuring the board with avrdude allows us to configure properties such as the microcontroller's clock rate.
    </p>

    <p>Since we have been issued the ATTiny85 instead of the ATTiny45, we can also use the shortcut T85.</p>

    <p>Use the C make file program to generate the program that we want to upload to the board</p>

    <h2>Software Installation</h2>

    <p>For this part on Embedded Programming, we will need to install several software.</p>

    <ul>

      <li>Git Bash</li>
      <li>Zadig</li>

    </ul>

    <p>We first start by installing Git from https://git-scm.com/download/win .</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/GITBASH1.png" width=75%>

    <p>We can download Zadig from https://zadig.akeo.ie/</p>

    <p>After this, we will also need to download some files and install them in their appropriate directories.</p>

    <ul>

      <li>AVR Toolchain</li>
      <li>AVR Dude</li>
      <li>GNU Make</li>

    </ul>

    <p>We can download AVRDude from http://fab.cba.mit.edu/classes/863.16/doc/projects/ftsmin/windows_avr.html </p>

    <p>Once downloaded, we'll extract it and copy it to our C://ProgramFiles Folder</p>

    <p>We will also need to update our PATH once we are done installing our files in our directories. Simply type 'PATH'
      into the windows search box: </p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/PATH.png" width=75%>

    <h2>Programming the ISP programmer</h2>

    <p>We'll first start by openning Git Bash:</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/GITBASH1.png" width=75%>

    <p>We can check that our ISP programmer is working by connecting it using the ISP cable and running the command
      "avrdude -p usbtiny -c t85"</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/GITBASH2.png" width=75%>

    <p>As can be seen, the device has been successfully initialised. Now that we have checked that our Tiny85 is
      working, we can now program it.</p>

    <p>We'll start by openning up command prompt and call directory into the directory that we have our firmware
      installed. </p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/part1.png" width=75%>]

    <p>Due to the firmware being in a folder with the same name, we can check that we are in the right folder by using
      the dir command to list the files in the directory.</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/part2.png" width=75%>

    <p>We then run the 'make' command</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/part3.png" width=75%>

    <p>Followed by the 'make flash' command</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/part4.png" width=75%>

    <p>We can then run the make fuses command</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/part5.png" width=75%>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/part6.png" width=75%>




    <img src="IMAGES/EMBEDDEDPROGRAMMING/partsomething.png" width=75%>

    <p>I also changed the MCU to the attiny85 from the attiny45 since we have been given tiny85s instead of tiny45s.
    </p>




    <h2>Setting up the Arduino as an ISP programmer</h2>

    <p>We'll be using SpenceKonde's ATTinyCore library which is hosted on github at:
      https://github.com/SpenceKonde/ATTinyCore</p>

    <p>There are 2 ways to setting up the Arduino IDE to act as an ISP programmer for our TINY85 target board.</p>

    <p>Firstly, there is the manual installation method. Download a package and extract it and copy it to the Arduino
      Library folder</p>

    <p>Secondly, there is the board manager url method, copy the URL to the Arduino library manager and it will
      automatically install the library. Since method is simpler due to only requiring a copy and paste of a link and
      a restart of the Arduino IDE and clicking of buttons, I will be using this method. The first method's
      documentation can be found in the
      installation tab on SpenceKonde's repository.</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/Arduinoconfigure.png" width=75%>

    <p>Simply copy "http://drazzy.com/package_drazzy.com_index.json" and paste it in the "Additional Boards Managers
      URLs" field.</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/Arduinoconfigure2.png" width=75%>

    <p>After restarting Arduino, we can now configure the settings for our Tiny85 board, such as the clock at which
      the Tiny85 is operating at, which Tiny chip we are using, etc</p>

    <p>After restarting Arduino, we'll head to our library manager where we'll finish off the installation by searching
      for 'Tiny' which will cause SpenceKonde's library to pop up. Click on 'Install'</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/Arduinoconfigure3.png" width=75%>

    <p>We can now select the Tiny25/45/85 as our board:</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/Arduinoconfigure4.png" width=75%>

    <p>One important thing to note is not to select an external clock in the Arduino IDE unless you have an external
      clock connected to the microcontroller. This will cause the
      board to stop working as it will keep waiting for an external clock at its clock pin. </p>

    <h3>Burning the Bootloader</h3>

    <p>If we change the internal clock frequency that the board is operating at, we will have to go into Arduino and
      'burn bootloader'. This will change the fuses to the appropriate setting. </p>

    <h3>Uploading the .ino file to the target board</h3>

    <p>Since we are using an ISP programmer and a target board, uploading to the target board will be slightly
      different from a traditional Arduino Uno.</p>

    <p>Instead of clicking the upload to board button at the top left of the IDE, we will have to go through "Tools"
      and "Upload using programmer", as compared to a traditional Arduino Uno or Mega.</p>

    <h2>Assignment</h2>

    <p>For our assignment, we have been tasked with reading a datasheet and programming our target board to do stuff.
    </p>
    <p>Programming the board to do stuff, send a button press through serial monitor or something</p>

    <h2>Reading a datasheet</h2>

    <p>Since I have already built a Tiny85 board, I will use its datasheet here.</p>

    <p>We first start by searching for 'Tiny85 datasheet' in our search engine of choice.</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/tiny85datasheet.png" width=75%>

    <p>The first search result here is from microchip showing the tiny25,45 and 85 datasheets.</p>

    <p>After clicking it, we get this:</p>

    <p>insert image here of cover page of the datasheet</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/datasheet1.png" width=75%>

    <h3>Feature/Summary page</h3>

    <p>Here we can see a brief summary of the features of the Tiny25/45/85 family. </p>

    <h3>1) Pin configuration:</h3>

    <p>Moving on, in this section of the datasheet, we can see that the Tiny25/45/85 microcontrollers are available in
      both
      PDIP/SOIC/TSSOP and QFN/MLF packages. In Section 1.1 we can also see a brief description of the various pins, for
      instance the self explantory VCC, ground as well as the features of the IO pins on Port B. For instance, the Port
      B IO pins also have internal pull up resistors.</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/datasheet2.png" width=75%>

    <!--

    <h3>4.41) SREG - AVR Status Register </h3>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/datasheet3.png" width=75%>

    <p>Here, we can see what the </p>

      -->

    <h2>Programming our target board:</h2>

    <p>Programming our target board with the Arduino as an ISP is almost the same as a regular Arduino Uno or Mega.
    </p>

    <p>Before programming our target board, we will first have to refer to the datasheet to understand the Pinout of
      the Tiny85.</p>

    <p>We will need to know the pinout to properly set-up our board.</p>

    <p>From my schematic, I know that I have my switch connected to PB3 and LED connected to PB4.</p>

    <p>I wrote a simple blink program for my board:</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/BlinkLEDcode.png" width=75% class="border">

    <video width=75% controls>

      <source src="IMAGES/EMBEDDEDPROGRAMMING/boardblinkvideo.mp4" width=75%>

    </video>

    <p>As seen from the code, the LED lights up for half a second where it is the pin it is connected to is set to HIGH,
      followed by another half a second
      where it is LOW, hence it blinking.</p>

    <p></p>

    <br>

    <p>Here is the code for a simple program where a button press switches on the LED:</p>

    <img src="IMAGES/EMBEDDEDPROGRAMMING/buttonLEDcode.png" width=75% class="border">

    <p>Since there is already a pullup resistor across my push button, by default the digitalRead will be HIGH since the
      push button has been 'pulled up' to 5V. Hence, it producing a 5V reading when the button is inactive and a 0V
      reading when pressed. Hence being active low</p>

    <p>By reading in the voltage as boolean, it will either be high when the button isn't pressed, and low when the
      button is pressed.</p>

    <p>I am thus able to invert the state of the button using the !state, using digitalRead to cause the LED to turn on
      when the button is pressed.</p>

    <p>Here is a video showing the LED turning on when the button is pressed:</p>

    <video width=75% controls>

      <source src="IMAGES/EMBEDDEDPROGRAMMING/buttonpressLED.mp4" width=75%>

    </video>

    <p>To finish off this embedded programming segment, I'll print the status of the LED on the serial monitor. For
      instance, a push button press toggles the LED status and it'll print on the serial monitor whether the LED has
      turned on or off.</p>

    <p>Insert imageS here</p>

    <p>Here is how the process goes:</p>

    <p>I first start by connecting my ISP programmer to a USB port on my laptop and connect the target board to my ISP
      programmer through the ISP header, ensuring that the header is connected appropriately with respect to 5V and GND.
    </p>

    <p>I then upload my .ino file, using "Upload through programmer" instead of upload.</p>

    <p>Now that the target board has been programmed, I remove my ISP programmer from the USB port and remove the ISP
      cable, connecting the target board to the FTDI board, ensuring that the cables are connected appropriately, for
      instance whether the TX and RX pins have been swapped in software.</p>

    <p>I then connect the FTDI board into the USB port. I then check which COM port the FTDI board is connected to and
      use the Arduino IDE to select the appropriate COM port.</p>

    <p>Lastly, I open the serial monitor to view any serial data that has been printed due to say, a button press on the board.</p>

    <p>Insert code here</p>

    <p>Insert video here</p>


  </div>